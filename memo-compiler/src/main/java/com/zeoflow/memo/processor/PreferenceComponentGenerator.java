/*
 * Copyright (C) 2017 zeoflow
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.zeoflow.memo.processor;

import androidx.annotation.NonNull;

import com.google.common.base.VerifyException;
import com.zeoflow.jx.file.ClassName;
import com.zeoflow.jx.file.FieldSpec;
import com.zeoflow.jx.file.MethodSpec;
import com.zeoflow.jx.file.ParameterSpec;
import com.zeoflow.jx.file.TypeName;
import com.zeoflow.jx.file.TypeSpec;
import com.zeoflow.memo.annotation.Encoder;
import com.zeoflow.memo.annotation.MemoStorage;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import javax.lang.model.element.ExecutableElement;
import javax.lang.model.util.Elements;

import static javax.lang.model.element.Modifier.PRIVATE;
import static javax.lang.model.element.Modifier.PUBLIC;
import static javax.lang.model.element.Modifier.STATIC;

@SuppressWarnings({"WeakerAccess", "SimplifyStreamApiCallChains"})
public class PreferenceComponentGenerator
{

    private static final String CLAZZ_PREFIX = "_Memo";
    private static final String ENTITY_PREFIX = "_MemoEntity";
    private static final String FIELD_INSTANCE = "instance";
    private static final String CONSTRUCTOR_CONTEXT = "context";
    private static final String ENTITY_NAME_LIST = "EntityNameList";
    private static final String PACKAGE_CONTEXT = "android.content.Context";
    private final PreferenceComponentAnnotatedClass annotatedClazz;
    private final Map<String, PreferenceEntityAnnotatedClass> annotatedEntityMap;
    private final Elements annotatedElementUtils;

    public PreferenceComponentGenerator(
            @NonNull PreferenceComponentAnnotatedClass annotatedClass,
            @NonNull Map<String, PreferenceEntityAnnotatedClass> annotatedEntityMap,
            @NonNull Elements elementUtils)
    {
        this.annotatedClazz = annotatedClass;
        this.annotatedEntityMap = annotatedEntityMap;
        this.annotatedElementUtils = elementUtils;
    }

    public TypeSpec generate()
    {
        return TypeSpec.classBuilder(getClazzName())
                .addJavadoc("Generated by Storage (https://github.com/zeoflow/storage).\n")
                .addModifiers(PUBLIC)
                .addSuperinterface(annotatedClazz.typeName)
                .addField(getInstanceFieldSpec())
                .addFields(getEntityInstanceFieldSpecs())
                .addMethods(addConstructorsSpec())
                .addMethods(addInitializeSpec())
                .addMethod(getInstanceSpec())
                .addMethods(getSuperEntityMethodSpecs())
                .addMethods(getSuperInjectionMethodSpecs())
                .addMethods(getEntityInstanceSpecs())
                .addMethod(getEntityNameListSpec())
                .build();
    }

    private FieldSpec getInstanceFieldSpec()
    {
        return FieldSpec.builder(getClassType(), FIELD_INSTANCE, PRIVATE, STATIC).build();
    }

    private List<FieldSpec> getEntityInstanceFieldSpecs()
    {
        List<FieldSpec> fieldSpecs = new ArrayList<>();
        this.annotatedClazz.keyNames.stream().forEach(
                keyName ->
                {
                    FieldSpec instance =
                            FieldSpec.builder(
                                    getEntityClassType(annotatedEntityMap.get(keyName)),
                                    getEntityInstanceFieldName(keyName),
                                    PRIVATE,
                                    STATIC)
                                    .build();
                    fieldSpecs.add(instance);
                });
        return fieldSpecs;
    }

    private List<MethodSpec> addConstructorsSpec()
    {
        List<MethodSpec> methods = new ArrayList<>();
        MethodSpec.Builder autoConstructor =
                MethodSpec.constructorBuilder()
                        .addModifiers(PRIVATE);
        autoConstructor.addJavadoc("Auto Constructor - the context is retrieved from StorageApplication");
        this.annotatedClazz.keyNames.stream().forEach(
                keyName ->
                        autoConstructor.addStatement(
                                "$N = $N.getInstance(getContext())",
                                getEntityInstanceFieldName(keyName),
                                getEntityClazzName(annotatedEntityMap.get(keyName))));

        methods.add(autoConstructor.build());
        MethodSpec.Builder constructor =
                MethodSpec.constructorBuilder()
                        .addModifiers(PRIVATE)
                        .addParameter(
                                ParameterSpec.builder(getContextPackageType(), CONSTRUCTOR_CONTEXT)
                                        .addAnnotation(NonNull.class)
                                        .build());
        this.annotatedClazz.keyNames.stream().forEach(
                keyName ->
                        constructor.addStatement(
                                "$N = $N.getInstance($N.getApplicationContext())",
                                getEntityInstanceFieldName(keyName),
                                getEntityClazzName(annotatedEntityMap.get(keyName)),
                                CONSTRUCTOR_CONTEXT));

        methods.add(constructor.build());

        return methods;
    }

    private List<MethodSpec> addInitializeSpec()
    {
        List<MethodSpec> methods = new ArrayList<>();
        MethodSpec autoInit = MethodSpec.methodBuilder("init")
                .addModifiers(PUBLIC, STATIC)
                .addJavadoc("Auto initializer - the context is retrieved from StorageApplication")
                .addStatement("if ($N != null) return $N", FIELD_INSTANCE, FIELD_INSTANCE)
                .addStatement("$N = new $N()", FIELD_INSTANCE, getClazzName())
                .addStatement("return $N", FIELD_INSTANCE)
                .returns(getClassType())
                .build();
        methods.add(autoInit);
        MethodSpec init = MethodSpec.methodBuilder("init")
                .addModifiers(PUBLIC, STATIC)
                .addParameter(
                        ParameterSpec.builder(getContextPackageType(), CONSTRUCTOR_CONTEXT)
                                .addAnnotation(NonNull.class)
                                .build())
                .addStatement("if ($N != null) return $N", FIELD_INSTANCE, FIELD_INSTANCE)
                .addStatement("$N = new $N($N)", FIELD_INSTANCE, getClazzName(), CONSTRUCTOR_CONTEXT)
                .addStatement("return $N", FIELD_INSTANCE)
                .returns(getClassType())
                .build();
        methods.add(init);
        return methods;
    }

    private MethodSpec getInstanceSpec()
    {
        return MethodSpec.methodBuilder("getInstance")
                .addModifiers(PUBLIC, STATIC)
                .addStatement("if($N != null) return $N", FIELD_INSTANCE, FIELD_INSTANCE)
                .addStatement("if(getContext() != null) return init()", FIELD_INSTANCE, FIELD_INSTANCE)
                .addStatement("else throw new VerifyError(\"component is not initialized.\")")
                .returns(getClassType())
                .build();
    }

    private List<MethodSpec> getEntityInstanceSpecs()
    {
        List<MethodSpec> methodSpecs = new ArrayList<>();
        this.annotatedClazz.keyNames.stream().forEach(
                keyName ->
                {
                    String fieldName = getEntityInstanceFieldName(keyName);
                    MethodSpec instance =
                            MethodSpec.methodBuilder(StringUtils.toUpperCamel(keyName))
                                    .addModifiers(PUBLIC)
                                    .addStatement("return $N", fieldName)
                                    .returns(getEntityClassType(annotatedEntityMap.get(keyName)))
                                    .build();
                    methodSpecs.add(instance);
                });
        return methodSpecs;
    }

    private List<MethodSpec> getSuperEntityMethodSpecs()
    {
        List<MethodSpec> methodSpecs = new ArrayList<>();
        this.annotatedClazz.annotatedElement.getEnclosedElements().stream()
                .filter(element -> element instanceof ExecutableElement)
                .map(element -> (ExecutableElement) element)
                .filter(method -> method.getParameters().size() == 0)
                .forEach(
                        method ->
                        {
                            String encodedString = Encoder.encodeUtf8(method.getReturnType() + ".class");
                            if (!annotatedClazz.entities.contains(encodedString))
                            {
                                throw new VerifyException(
                                        String.format("'%s' method can return only an entity type.", method));
                            }

                            annotatedEntityMap.values().stream()
                                    .filter(
                                            clazz ->
                                                    method
                                                            .getReturnType()
                                                            .toString()
                                                            .equals(clazz.annotatedElement.toString()))
                                    .forEach(
                                            clazz ->
                                            {
                                                String instance = getEntityInstanceFieldName(clazz.entityName);
                                                MethodSpec.Builder builder = MethodSpec.overriding(method);
                                                MethodSpec methodSpec = builder.addStatement("return $N", instance).build();
                                                methodSpecs.add(methodSpec);
                                            });
                        });
        return methodSpecs;
    }

    private List<MethodSpec> getSuperInjectionMethodSpecs()
    {
        List<MethodSpec> methodSpecs = new ArrayList<>();
        this.annotatedClazz.annotatedElement.getEnclosedElements().stream()
                .filter(element -> element instanceof ExecutableElement)
                .map(element -> (ExecutableElement) element)
                .filter(method -> method.getParameters().size() == 1)
                .forEach(
                        method ->
                        {
                            ClassName preferenceRoom = ClassName.get(MemoStorage.class);
                            MethodSpec.Builder builder = MethodSpec.overriding(method);
                            MethodSpec methodSpec = builder
                                    .addStatement(
                                            "$T.inject($N)",
                                            preferenceRoom,
                                            method.getParameters().get(0).getSimpleName())
                                    .build();
                            methodSpecs.add(methodSpec);
                        });
        return methodSpecs;
    }

    private MethodSpec getEntityNameListSpec()
    {
        MethodSpec.Builder builder =
                MethodSpec.methodBuilder("get" + ENTITY_NAME_LIST)
                        .addModifiers(PUBLIC)
                        .returns(List.class)
                        .addStatement("List<String> $N = new $T<>()", ENTITY_NAME_LIST, ArrayList.class);

        this.annotatedClazz.keyNames.stream().forEach(
                entityName -> builder.addStatement("$N.add($S)", ENTITY_NAME_LIST, entityName));

        builder.addStatement("return $N", ENTITY_NAME_LIST);
        return builder.build();
    }

    private ClassName getClassType()
    {
        return ClassName.get(annotatedClazz.packageName, getClazzName());
    }

    private String getClazzName()
    {
        return annotatedClazz.clazzName + CLAZZ_PREFIX;
    }

    private ClassName getEntityClassType(PreferenceEntityAnnotatedClass annotatedClass)
    {
        return ClassName.get(annotatedClass.packageName, getEntityClazzName(annotatedClass));
    }

    private String getEntityClazzName(PreferenceEntityAnnotatedClass annotatedClass)
    {
        return annotatedClass.entityName + ENTITY_PREFIX;
    }

    private String getEntityInstanceFieldName(String keyName)
    {
        return FIELD_INSTANCE + StringUtils.toUpperCamel(keyName);
    }

    private TypeName getContextPackageType()
    {
        return TypeName.get(annotatedElementUtils.getTypeElement(PACKAGE_CONTEXT).asType());
    }

}
